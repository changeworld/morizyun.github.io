<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AOJ | 酒と泪とRubyとRailsと]]></title>
  <link href="http://morizyun.github.io/blog/categories/aoj/atom.xml" rel="self"/>
  <link href="http://morizyun.github.io/"/>
  <updated>2015-12-30T21:03:25+09:00</updated>
  <id>http://morizyun.github.io/</id>
  <author>
    <name><![CDATA[morizyun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[アルゴリズムの勉強: 最大公約数、最小公倍数[AOJ 0005][Ruby][Python][Java]]]></title>
    <link href="http://morizyun.github.io/blog/gcd-lcm-euclidean-algorithm-aoj-0005/"/>
    <updated>2014-09-03T20:55:00+09:00</updated>
    <id>http://morizyun.github.io/blog/gcd-lcm-euclidean-algorithm-aoj-0005</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4797341378/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4797341378&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4797341378&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="150" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4797341378" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />今回は、『<strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0005">最大公約数と最小公倍数</a></strong>』に関する問題です。</p>

<p>整数における最大公約数を求めるアルゴリズムは、『<strong><a href="http://www.amazon.co.jp/gp/product/4797341378/ref=as_li_qf_sp_asin_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4797341378&amp;linkCode=as2&amp;tag=morizyun00-22">ユークリッドの互除法</a></strong>』が有名です。今回はこのアルゴリズムを使って、コードを書いていきます。</p>

<p><strong>(09/03 20:55) Java 追加しました！</strong></p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>最大公約数、最小公倍数のRubyサンプルソース</h2>

<p>{% codeblock lang:ruby %}</p>

<h1>最大公約数</h1>

<p>def gcd(a, b)
  a, b = b, a if a > b
  until a == 0</p>

<pre><code>a, b = b%a, a
</code></pre>

<p>  end
  return b
end</p>

<h1>最小公倍数</h1>

<p>def lcm(a, b)
  a*b/gcd(a, b)
end</p>

<p>while gets do
  a, b = $_.chomp.split(' ').map(&amp;:to_i)
  puts "#{gcd(a, b)} #{lcm(a, b)}"
end
{% endcodeblock %}</p>

<h2>最大公約数、最小公倍数のPythonサンプルソース</h2>

<p>{% codeblock lang:python %}</p>

<h1>coding:utf-8</h1>

<p>import sys</p>

<h1>最大公約数</h1>

<p>def gcd(a, b):
  while b > 0:</p>

<pre><code>a, b = b, a%b
</code></pre>

<p>  return a</p>

<h1>最小公倍数</h1>

<p>def lcm(a, b):
  return a*b/gcd(a, b)</p>

<p>for s in sys.stdin:
  a, b = map(int,s.split())
  gcd_num = gcd(a, b)
  lcm_num = lcm(a, b)
  print "%d %d"%(gcd_num, lcm_num)</p>

<h1>output</h1>

<h1>2 24</h1>

<h1>10000000 150000000</h1>

<p>{% endcodeblock %}</p>

<h2>最大公約数、最小公倍数のJavaのサンプルソース</h2>

<p>{% codeblock lang:java %}
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.Exception;
import java.lang.String;
import java.lang.System;</p>

<p>public class Main {</p>

<pre><code>public static void main(String[] a) throws Exception {
    BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
    long num[] = new long[2];
    long gcd, lcm;
    String numStr[] = new String[2];
    String str;

    while((str = r.readLine()) != null) {
        numStr = str.split(" ");
        for(int i = 0; i &lt; numStr.length; i++) {
            num[i] = Long.parseLong(numStr[i]);
        }
        gcd = getGCD(num[0], num[1]);
        lcm = getLCM(num[0], num[1]);
        System.out.printf("%d %d\n", gcd, lcm);
    }
}

// a, bの最大公約数を求める
private static long getGCD(long a, long b) {
    if(a &gt; b) {
        long tmp;
        tmp = a;
        a = b;
        b = tmp;
    }

    while(a != 0) {
        long tmp = a;
        a = b%a;
        b = tmp;
    }

    return b;
}

// a, bの最小公倍数を求める
private static long getLCM(long a, long b) {
    return (a * b)/getGCD(a, b);
}
</code></pre>

<p>}</p>

<h1>output</h1>

<h1>2 24</h1>

<h1>10000000 150000000</h1>

<p>{% endcodeblock %}</p>

<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>Aizu Online Judgeのサンプルソース</h2>

<p>当面はAOJを解きながら、アルゴリズムの再勉強をしていくつもりです。Ruby/Python/JavaでのAOJの回答は下のリポジトリに保存しておきます。もしツッコミとかあれば是非＾＾</p>

<p><strong><a href="https://github.com/morizyun/aoj-ruby-python">morizyun/aoj-ruby-python - GitHub</a></strong></p>

<h2>最近解いたAOJの問題</h2>

<p><strong><a href="/blog/categories/AOJ/">AOJタグのついた最近解いた問題一覧</a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アルゴリズムの勉強: 動的計画法[AOJ 0557][Ruby][Python]]]></title>
    <link href="http://morizyun.github.io/blog/a-first-grader-dinamic-programming-algorithm-aoj-0557/"/>
    <updated>2014-06-22T22:00:00+09:00</updated>
    <id>http://morizyun.github.io/blog/a-first-grader-dinamic-programming-algorithm-aoj-0557</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4844335928/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4844335928&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4844335928&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="150" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4844335928" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />今回は、『<strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0557">AOJ 0557 - 動的計画法</a></strong>』についての記事です。</p>

<p>動的計画法(Dynamic Programming, DP)は、ベーシックなアルゴリズムの一つです。動的計画法は次の条件を満たす必要があります。</p>

<pre>
分割統治法：部分問題を解き、その結果を利用して、問題全体を解く
メモ化：部分問題の計算結果を再利用する 
</pre>




<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>Ruby サンプルソース</h2>

<p>{% codeblock lang:ruby %}
n = gets.to_i
arr = gets.split(' ').map(&amp;:to_i)
answer = arr[n-1]</p>

<p>dp = n.times.map { [0]*21 }
dp[0][arr[0]] = 1
1.upto(n-2) do |i|
  0.upto(20) do |j|</p>

<pre><code>next if dp[i-1][j] &lt;= 0
cp = j + arr[i]
cm = j - arr[i]

dp[i][cp] += dp[i-1][j] if cp &lt;= 20
dp[i][cm] += dp[i-1][j] if cm &gt;= 0
</code></pre>

<p>  end
end</p>

<p>puts dp[n-2][answer]
{% endcodeblock %}</p>

<h2>Python サンプルソース</h2>

<p>{% codeblock lang:python %}
n = input()
arr = map(int, raw_input().split())
answer = arr[n-1]</p>

<p>dp = [[0]*21 for i in range(n)]
dp[0][arr[0]] = 1</p>

<p>for i in range(1, n-1):
  for j in range(21):</p>

<pre><code>if dp[i-1][j] == 0: continue
vp = j + arr[i]
vm = j - arr[i]

if vp &lt;= 20:
  dp[i][vp] += dp[i-1][j]
if vm &gt;= 0:
  dp[i][vm] += dp[i-1][j]
</code></pre>

<p>print dp[n-2][answer]
{% endcodeblock %}</p>

<p>シンプルですがかなり強力なアルゴリズムなので知っておいて損はないと思います。是非トライしてみてください！</p>

<h2>Aizu Online Judgeのサンプルソース</h2>

<p>当面はAOJを解きながら、アルゴリズムの再勉強をしていくつもりです。Ruby/PythonでのAOJの回答は下のリポジトリに保存しておきます。もしツッコミとかあれば是非＾＾</p>

<p><strong><a href="https://github.com/morizyun/aoj-ruby-python">morizyun/aoj-ruby-python - GitHub</a></strong></p>

<h2>最近解いたAOJの問題</h2>

<p><strong><a href="/blog/categories/AOJ/">AOJタグのついた最近解いた問題一覧</a></strong></p>

<p>{% include custom/google_ads_yoko_naga.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アルゴリズムの勉強: うるう年(leap year)[AOJ 0093][Ruby]]]></title>
    <link href="http://morizyun.github.io/blog/leap-year-algorithm-aoj-0093/"/>
    <updated>2014-06-22T10:30:00+09:00</updated>
    <id>http://morizyun.github.io/blog/leap-year-algorithm-aoj-0093</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4774165166/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4774165166&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4774165166&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="150" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4774165166" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />今回は、『<strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=10029">AOJ 0093 - うるう年(leap year)</a></strong>』についての記事です。</p>

<p>プログラムならうるう年を求めるのもこんなに簡単なのかとちょっと感激しますw、よかったらぜひチャレンジしてみてください。</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>クイックソートのRubyサンプルソース</h2>

<p>{% codeblock lang:ruby %}
def get_leap_years(from, to)
  res = []
  from.upto(to) do |i|</p>

<pre><code>if i%400 == 0
  res &lt;&lt; i
elsif i%100 == 0
  next
elsif i%4 == 0
  res &lt;&lt; i
end
</code></pre>

<p>  end
  res
end</p>

<p>is_first_line = true
while gets do
  a, b = $_.split(' ').map(&amp;:to_i)
  break if a == 0 &amp;&amp; b == 0</p>

<p>  if is_first_line</p>

<pre><code>is_first_line = false
</code></pre>

<p>  else</p>

<pre><code>puts ''
</code></pre>

<p>  end</p>

<p>  res = get_leap_years(a, b)
  if res.count == 0</p>

<pre><code>puts 'NA'
</code></pre>

<p>  else</p>

<pre><code>puts res
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<h2>Aizu Online Judgeのサンプルソース</h2>

<p>当面はAOJを解きながら、アルゴリズムの再勉強をしていくつもりです。Ruby/Python/C++でのAOJの回答は下のリポジトリに保存しておきます。もしツッコミとかあれば是非＾＾</p>

<p><strong><a href="https://github.com/morizyun/aoj-ruby-python">morizyun/aoj-ruby-python - GitHub</a></strong></p>

<h2>最近解いたAOJの問題</h2>

<p><strong><a href="/blog/categories/AOJ/">AOJタグのついた最近解いた問題一覧</a></strong></p>

<p>{% include custom/google_ads_yoko_naga.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アルゴリズムの勉強: クイックソート、マージソート[AOJ 10029][Ruby]]]></title>
    <link href="http://morizyun.github.io/blog/quick-sort-merge-sort-algorithm-aoj-10029/"/>
    <updated>2014-06-22T08:50:00+09:00</updated>
    <id>http://morizyun.github.io/blog/quick-sort-merge-sort-algorithm-aoj-10029</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4775991280/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4775991280&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4775991280&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="150" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4775991280" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />今回は、『<strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=10029">AOJ 10029 - ソートアルゴリズム(クイックソート、マージソート)</a></strong>』についての記事です。</p>

<p>勉強のためにクイックソートと、マージソートを書いてみました。一般的にはマージソートよりもクイックソートの方が高速です。しかし、AOJで実際にプログラムを書いて実感しましたが、『<strong>クイックソートのアルゴリズムはソート対象によって計算量が変わる</strong>』ので、計算量が安定しているという意味では、マージソートの方が優れていることを知りました。でもそれ以上に、Rubyの実装の方が安定かつ高速なので、普段からプラットフォームの恩恵にあずかっていることを実感しました！</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>クイックソートのRubyサンプルソース</h2>

<p>{% codeblock lang:ruby %}
class Array
  def quick_sort</p>

<pre><code>return self if length &lt;= 1
base = pop
smaller, bigger = partition { |e| e &lt; base }
push base
smaller.quick_sort + [base] + bigger.quick_sort
</code></pre>

<p>  end
end</p>

<p>n = gets.to_i
arr = gets.split(' ').map(&amp;:to_i)</p>

<p>puts arr.quick_sort.join(' ')
{% endcodeblock %}</p>

<h2>マージソートのRubyサンプルソース</h2>

<p>{% codeblock lang:ruby %}
class Array
  def merge_sort</p>

<pre><code>tmp = self.dup
return tmp if tmp.length &lt;= 1
a, b = self.half.map { |e| e.merge_sort }
marge(a, b)
</code></pre>

<p>  end</p>

<p>  def half</p>

<pre><code>mid = length/2
return slice(0...mid), slice(mid..-1)
</code></pre>

<p>  end</p>

<p>  def marge(a, b)</p>

<pre><code>res = []
until a.empty? and b.empty?
  res &lt;&lt;
      case
        when a.empty? then b.shift
        when b.empty? then a.shift
        when a.first &gt; b.first then b.shift
        else a.shift
      end
end
res
</code></pre>

<p>  end
end</p>

<p>n = gets.to_i
arr = gets.split(' ').map(&amp;:to_i)</p>

<p>res = arr.merge_sort
puts res.join(' ')
{% endcodeblock %}</p>

<h2>2つのサンプルを使って比較</h2>

<p>2つのランダムな配列を使ってテストをします。2つのサンプルは次のように作成します。</p>

<pre>
* 0-100000の数字を100,000個、ランダムに並べる場合
* 0-100の数字を100,000個、ランダムに並べる場合
</pre>


<p>比較結果は次の通り。</p>

<p>{% codeblock lang:ruby %}</p>

<h6>#</h6>

<p>sample = (0..100000).sort_by { rand }</p>

<p>puts Benchmark::CAPTION
puts 'quick_sort: ' + Benchmark.measure { sample.quick_sort }.to_s
puts 'marge_sort: ' + Benchmark.measure { sample.merge_sort }.to_s
puts 'ruby_sort:  ' + Benchmark.measure { sample.sort }.to_s</p>

<h1>0-100000の数字を100,000個、ランダムに並べる場合</h1>

<h1>user     system      total        real</h1>

<h1>quick_sort:   0.250000   0.000000   0.250000 (  0.253962)</h1>

<h1>marge_sort:   0.340000   0.000000   0.340000 (  0.349896)</h1>

<h1>ruby_sort:    0.020000   0.010000   0.030000 (  0.015256)</h1>

<h6>#</h6>

<p>sample = (1..1000).map{ (0..100).sort_by { rand } }.flatten</p>

<p>puts Benchmark::CAPTION
puts 'quick_sort: ' + Benchmark.measure { sample.quick_sort }.to_s
puts 'marge_sort: ' + Benchmark.measure { sample.merge_sort }.to_s
puts 'ruby_sort:  ' + Benchmark.measure { sample.sort }.to_s</p>

<h1>0-100の数字を100,000個、ランダムに並べる場合</h1>

<h1>user     system      total        real</h1>

<h1>quick_sort:   4.490000   0.040000   4.530000 (  4.529826)</h1>

<h1>marge_sort:   0.370000   0.010000   0.380000 (  0.371850)</h1>

<h1>ruby_sort:    0.000000   0.000000   0.000000 (  0.006622)</h1>

<p>{% endcodeblock %}</p>

<p>マージソートはどちらも安定していますが、クイックソートは入力の配列に寄っては計算量がかなり増加しています。これはクイックソートが入力の配列によっては、1:N-1のソートを繰り返すためとのこと。</p>

<p><strong><a href="http://goo.gl/78wTU">クイックソート - Wikipedia</a></strong></p>

<p><strong><a href="http://goo.gl/9Tb58">マージソート - Wikipedia</a></strong></p>

<p>ちなみに、RubyのCでのソートアルゴリズムもクイックソートだそうですが、この辺りもきちっと考慮されているようです。こういった部分も普段からRuby(言語開発者の方々)の恩恵に預かっているんだなぁ＾＾；</p>

<h2>Aizu Online Judgeのサンプルソース</h2>

<p>当面はAOJを解きながら、アルゴリズムの再勉強をしていくつもりです。Ruby/PythonでのAOJの回答は下のリポジトリに保存しておきます。もしツッコミとかあれば是非＾＾</p>

<p><strong><a href="https://github.com/morizyun/aoj-ruby-python">morizyun/aoj-ruby-python - GitHub</a></strong></p>

<h2>最近解いたAOJの問題</h2>

<p><strong><a href="/blog/categories/AOJ/">AOJタグのついた最近解いた問題一覧</a></strong></p>

<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>Special Thanks</h2>

<p><strong><a href="http://melborne.github.io/2010/10/12/Ruby/">Rubyでソート・アルゴリズムを表現しよう!</a></strong></p>

<p><strong><a href="http://qiita.com/7kaji/items/5518479579bc36359bc8">Rubyでクイックソート - Qiita</a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アルゴリズムの勉強: 二股に分かれている容器にボールを入れる[AOJ 0033][Ruby/Python/c++]]]></title>
    <link href="http://morizyun.github.io/blog/ball-algorithm-aoj-0033/"/>
    <updated>2014-05-18T19:15:00+09:00</updated>
    <id>http://morizyun.github.io/blog/ball-algorithm-aoj-0033</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4839941068/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4839941068&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4839941068&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="150" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4839941068" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />今回は、『<strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0033">二股に分かれている容器にボールを入れる</a></strong>』問題です。</p>

<p>二股にわかれた容器に番号のついたボールを番号の大小関係の制約を守って並べていく問題です。</p>

<p>これはどれだけ問題をシンプルに考えられるかという点の思考が必要になるので、難しい戦略を考えるのとは別の思考が必要で、これはこれで面白かったです！</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_yoko_naga.html %}</p>

<h2>Rubyのサンプルソース</h2>

<p>{% codeblock lang:ruby %}
num = gets.to_i
num.times do
  left, right = [], []
  arr = gets.chomp.split(' ').map(&amp;:to_i)
  arr.each do |a|</p>

<pre><code>if (left.last || 0) &lt; a
  left &lt;&lt; a
elsif (right.last || 0) &lt; a
  right &lt;&lt; a
else
  break
end
</code></pre>

<p>  end
  puts (arr.size == (left.size + right.size)) ? 'YES' : 'NO'
end
{% endcodeblock %}</p>

<h2>Pythonのサンプルソース</h2>

<p>{% codeblock lang:python %}
n = int(raw_input())
for i in range(n):
  left, right = [], []
  arr = map(int, raw_input().split(' '))
  for a in arr:</p>

<pre><code>if len(left) == 0 or left[len(left)-1] &lt; a:
  left.append(a)
elif len(right) == 0 or right[len(right)-1] &lt; a:
  right.append(a)
else:
  break
</code></pre>

<p>  if len(arr) == len(left) + len(right):</p>

<pre><code>print 'YES'
</code></pre>

<p>  else:</p>

<pre><code>print 'NO'
</code></pre>

<p>{% endcodeblock %}</p>

<h2>c++のサンプルソース</h2>

<p>{% codeblock lang:c %}</p>

<h1>include <iostream></h1>

<h1>include &lt;stdio.h></h1>

<p>using namespace std;</p>

<p>int a[10];</p>

<p>bool dfs(int i, int left, int right) {
  if(i == 10) { return true; }</p>

<p>  bool ans = false;
  if(left &lt; a[i]) {</p>

<pre><code>ans = dfs(i+1, a[i], right);
</code></pre>

<p>  }
  if(right &lt; a[i]) {</p>

<pre><code>ans = dfs(i+1, left, a[i]);
</code></pre>

<p>  }
  return ans;
}</p>

<p>int main() {
  int n;
  scanf("%d", &amp;n);</p>

<p>  for(int i = 0; i &lt; n; i++) {</p>

<pre><code>for(int j = 0; j &lt; 10; j++) {
  scanf("%d", &amp;a[j]);
}
cout &lt;&lt; (dfs(0, 0, 0) ? "YES" : "NO") &lt;&lt; endl;
</code></pre>

<p>  }
  return 0;
}
{% endcodeblock %}</p>

<h2>Aizu Online Judgeのサンプルソース</h2>

<p>当面はAOJを解きながら、アルゴリズムの再勉強をしていくつもりです。Ruby/PythonでのAOJの回答は下のリポジトリに保存しておきます。もしツッコミとかあれば是非＾＾</p>

<p><strong><a href="https://github.com/morizyun/aoj-ruby-python">morizyun/aoj-ruby-python - GitHub</a></strong></p>

<h2>最近解いたAOJの問題</h2>

<p><strong><a href="/blog/categories/AOJ/">AOJタグのついた最近解いた問題一覧</a></strong></p>

<p>{% include custom/google_ads_yoko_naga.html %}</p>
]]></content>
  </entry>
  
</feed>
