<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design Pattern | 酒と泪とRubyとRailsと]]></title>
  <link href="http://morizyun.github.io/blog/categories/design-pattern/atom.xml" rel="self"/>
  <link href="http://morizyun.github.io/"/>
  <updated>2016-01-12T23:56:30+09:00</updated>
  <id>http://morizyun.github.io/</id>
  <author>
    <name><![CDATA[morizyun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[アブストラクトファクトリ Ruby 2.0.0 デザインパターン速攻習得[Abstract Factory][Design Pattern]]]></title>
    <link href="http://morizyun.github.io/blog/ruby-design-pattern-14-abstract-factory/"/>
    <updated>2015-05-26T20:00:00+09:00</updated>
    <id>http://morizyun.github.io/blog/ruby-design-pattern-14-abstract-factory</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4894712857&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4894712857&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="200" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4894712857" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />GoFのデザインパターン(Design Pattern)の一つ、アブストラクトファクトリ(Abstract Factory)をRubyのサンプルコードで紹介します。</p>

<p>アブストラクトファクトリは、矛盾のないオブジェクトの生成を行うためのパターンです。</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_square.html %}</p>

<h2>ソースコードを使ったAbstract Factoryの説明</h2>

<p>Abstract Factoryをソースコードを使って説明します。<br/>
ここでは次のような池をサンプルとして取り上げます。</p>

<pre>
* 動物を表すクラス:
  * アヒルを表すDuckクラスは、食事(eat)メソッドを持っている
  * カエルを表すFrogクラスは、食事(eat)メソッドを持っている

* 植物を表すクラス:
  * 藻を表すAlgaeクラスは、成長(grow)メソッドを持っている
  * スイレンを表すWaterLilyクラスは、成長(grow)メソッドを持っている

池の生態系を生成するクラス:
  * コンストラクタで動物と植物を定義する
  * 動物、植物のオブジェクトを返すメソッドを持っている

* 池の環境(動物と植物の組み合わせ)は次の2種類のみが許されている
  * DuckとWaterLily
  * FrogとAlgae
</pre>


<p>上を満たすコードを書いていきます。</p>

<p>まず、アヒル(Duckクラス)とカエル(Frogクラス)は次のようになります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>アヒル</h1>

<p>class Duck
  def initialize(name)</p>

<pre><code>@name = name
</code></pre>

<p>  end</p>

<p>  # 食べる(eat)
  def eat</p>

<pre><code>puts "アヒル #{@name} は食事中です"
</code></pre>

<p>  end
end</p>

<h1>カエル</h1>

<p>class Frog
  def initialize(name)</p>

<pre><code>@name = name
</code></pre>

<p>  end</p>

<p>  # 食べる(eat)
  def eat</p>

<pre><code>puts "カエル #{@name} は食事中です"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>一方、藻(Algaeクラス)とスイレン(WaterLilyクラス)のは次のようになります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>植物/藻</h1>

<p>class Algae
  def initialize(name)</p>

<pre><code>@name = name
</code></pre>

<p>  end</p>

<p>  def grow</p>

<pre><code>puts "藻 #{@name} は成長中です"
</code></pre>

<p>  end
end</p>

<h1>植物/スイレン</h1>

<p>class WaterLily
  def initialize(name)</p>

<pre><code>@name = name
</code></pre>

<p>  end</p>

<p>  def grow</p>

<pre><code>puts "スイレン #{@name} は成長中です"
</code></pre>

<p>  end
end</p>

<p>{% endcodeblock %}</p>

<p>次に池を作成する前に、「池の環境の制約」について考えます。</p>

<pre>
* 池の環境(動物と植物の組み合わせ)は2種類のみが許されている
  * アヒル(Duckクラス)とスイレン(WaterLilyクラス)
  * カエル(Frogクラス)と藻(Algaeクラス)
</pre>


<p>この池の環境の制約を守ること、<strong>言い換えると矛盾のないオブジェクトの組み合わせを作る</strong>のが「<strong>Abstract Factoryパターン</strong>」です。
今回はこの矛盾のない環境の作成を次の２つのクラスに担当してもらいます。</p>

<pre>
* カエル(Frog)と藻(Algae)の生成を行う => FrogAndAlgaeFactory
* アヒル(Duck)とスイレン(WaterLily)の生成を行う => DuckAndWaterLilyFactory
</pre>


<p>さらに上の２つのクラスのベースとなる池の生態系を表すクラス<code>OrganismFactory</code>を作り、上記のクラスが継承するようにします。</p>

<p>ということで、ソースコードはこちら。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>池の生態系を作る (Abstract Factory)</h1>

<p>class OrganismFactory
  def initialize(number_animals, number_plants)</p>

<pre><code>@animals = []
# 池の動物を定義する
number_animals.times do |i|
  animal = new_animal("動物 #{i}")
  @animals &lt;&lt; animal
end

@plants = []
# 池の植物を定義する
number_plants.times do |i|
  plant = new_plant("植物 #{i}")
  @plants &lt;&lt; plant
end
</code></pre>

<p>  end</p>

<p>  # 植物についてのオブジェクトを返す
  def get_plants</p>

<pre><code>@plants
</code></pre>

<p>  end</p>

<p>  # 動物についてのオブジェクトを返す
  def get_animals</p>

<pre><code>@animals
</code></pre>

<p>  end
end</p>

<h1>カエル(Frog)と藻(Algae)の生成を行う (Concrete Factory)</h1>

<p>class FrogAndAlgaeFactory &lt; OrganismFactory
  private</p>

<p>  def new_animal(name)</p>

<pre><code>Frog.new(name)
</code></pre>

<p>  end</p>

<p>  def new_plant(name)</p>

<pre><code>Algae.new(name)
</code></pre>

<p>  end
end</p>

<h1>アヒル(Duck)とスイレン(WaterLily)の生成を行う(Concrete Factory)</h1>

<p>class DuckAndWaterLilyFactory &lt; OrganismFactory
  private</p>

<p>  def new_animal(name)</p>

<pre><code>Duck.new(name)
</code></pre>

<p>  end</p>

<p>  def new_plant(name)</p>

<pre><code>WaterLily.new(name)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>上のプログラムを実行した結果を載せておきます。</p>

<p>{% codeblock lang:ruby %}
factory = FrogAndAlgaeFactory.new(4,1)
animals = factory.get_animals
animals.each { |animal| animal.eat }</p>

<h1>=> カエル 動物 0 は食事中です</h1>

<h1>=> カエル 動物 1 は食事中です</h1>

<h1>=> カエル 動物 2 は食事中です</h1>

<h1>=> カエル 動物 3 は食事中です</h1>

<p>plants = factory.get_plants
plants.each { |plant| plant.grow }</p>

<h1>=> 藻 植物 0 は成長中です</h1>

<p>factory = DuckAndWaterLilyFactory.new(3,2)
animals = factory.get_animals
animals.each { |animal| animal.eat }</p>

<h1>=> アヒル 動物 0 は食事中です</h1>

<h1>=> アヒル 動物 1 は食事中です</h1>

<h1>=> アヒル 動物 2 は食事中です</h1>

<p>plants = factory.get_plants
plants.each { |plant| plant.grow }</p>

<h1>=> スイレン 植物 0 は成長中です</h1>

<h1>=> スイレン 植物 1 は成長中です</h1>

<p>{% endcodeblock %}</p>

<p>矛盾のない組み合わせて、オブジェクトを生成できた事がわかります。</p>

<p>このサンプルソースはGitHubにも置いています。</p>

<p><a href="https://github.com/morizyun/ruby_design_pattern_sample" class="button big primary">サンプルソース(GitHub)</a></p>

<h2>Abstract Factoryの構成</h2>

<p>Abstract Factoryは次の３つの要素で構成されています。</p>

<pre>
AbstractFactory: ConcreteFactoryの共通部分の処理を行う(この例ではPond)
ConcreteFactory: 実際にオブジェクトの生成を行う
(この例ではFrogAndAlgaeFactoryとDuckAndWaterLilyFactoryクラス)
Product: ConcreteFactoryによって生成される側のオブジェクト
(この例では、Duck，Frog, WaterLily, algaeクラス)
</pre>


<h2>アブストラクトファクトリのメリットは？</h2>

<pre>
* 関連し合うオブジェクトの集まりを生成することができる
* 整合性が必要となるオブジェクト群を誤りなしに生成できる
</pre>


<h2>Special Thanks</h2>

<p><a href="https://twitter.com/chinmo">@chinmo</a>さんにアブストラクトファクトリについて<a href="https://gist.github.com/chinmo/6195212">コード付きのコメント</a>を頂きました。深謝です！</p>

<p>ma2さんにブログ上に記述したコードがOrganismFactoryを継承していない部分のミスをご指摘頂きました。ミスすんませんでした＆ma2さん、本当に有難うございます！</p>

<p><a href="http://murayama.hatenablog.com/entry/20090706/1246855224">Factory - Murayama Blog.</a></p>

<p><a href="http://capm-network.com/?tag=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-AbstractFactory">デザインパターン-AbstractFactory</a></p>

<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4894712857&amp;linkCode=as2&amp;tag=morizyun00-22">Amazon.co.jp： Rubyによるデザインパターン: Russ Olsen, ラス・オルセン, 小林 健一, 菅野 裕, 吉野 雅人, 山岸 夢人, 小島 努: 本</a></p>

<h2>変更来歴</h2>

<p>12/12/10 23:10 11回FactoryをFactoryMethodとAbstractFactoryに分割<br/>
12/12/11 00:00 書籍へのリンクをAmazon アフィリエイトに変更<br/>
13/06/21 19:10 Ruby2.0.0対応、読みづらい部分を修正<br/>
13/08/15 13:15 モデリング・説明が不適切だったため、修正<br/>
14/01/18 09:35 継承の記述が抜けていたため、修正<br/>
15/05/26 20:00 コメントの記述にミスがあったので修正<br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オブザーバー Ruby 2.0.0 デザインパターン速攻習得[Observer][Design Pattern]]]></title>
    <link href="http://morizyun.github.io/blog/ruby-design-pattern-03-Observer/"/>
    <updated>2015-01-16T20:50:00+09:00</updated>
    <id>http://morizyun.github.io/blog/ruby-design-pattern-03-Observer</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4894712857&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4894712857&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="200" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4894712857" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />GoFのデザインパターン(Design Pattern)のオブザーバー(Observer)のRubyコードを使った紹介記事です。</p>

<p>次の条件を満たす場合にオブザーバーパターンを使います。</p>

<pre>
* オブジェクトの状態が変化する可能性がある
* 変化したことを他のオブジェクトに通知する必要がある
</pre>


<p>例としては、Aで起きたイベントをB, Cが知る必要が有る場合などです。</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_square.html %}</p>

<h2>オブザーバーとは？</h2>

<p>あるオブジェクトの状態が変化した際に、そのオブジェクト自身が「観察者」に「通知」する仕組みです。オブザーバは以下の3つのオブジェクトによって構成されます。</p>

<pre>
サブジェクト(subject)：変化する側のオブジェクト
オブザーバ(Observer)：状態の変化を関連するオブジェクトに通知するインタフェース
具象オブザーバ(ConcreteObserver)：状態の変化に関連して具体的な処理を行う
</pre>


<h2>オブザーバのメリット</h2>

<pre>
オブジェクト間の依存度を下げることができる
通知先の管理をオブザーバが行うことで、サブジェクトは通知側を意識しなくていい
</pre>


<h2>サンプルソース</h2>

<p>次のようなモデルを通してObserverデザインパターンを説明します。</p>

<pre>
Employee(サブジェクト)：従業員を表す
Observable(オブザーバ)：従業員のニュースを監視する仕組み(observer/Observable)
Payroll(具体オブザーバ１)：給与の小切手の発行を行う
TaxMan(具体オブザーバ２)：税金の請求書の発行を行う
</pre>


<p>まずは従業員を表すEmployeeクラスについてです。このEmployeeクラスは、<code>name, title, salary</code>といったデータと、salaryの変更を受け付けるメソッドを持っています。</p>

<p>さらに、Employeeクラスに<code>observable</code>をincludeします。<code>observable</code>はオブザーバーとしての機能を持ったrubyの標準モジュールです。</p>

<p><code>observable</code>で用いるメソッドは次のとおりです。</p>

<ul>
<li><code>add_observer</code>メソッドで通知する先のオブジェクトを追加</li>
<li><code>changed</code>メソッドと<code>notify_observers</code>メソッドでオブジェクトに通知</li>
</ul>


<p>こちらが、Employeeクラスの実装です。</p>

<p>{% codeblock lang:ruby %}
require 'observer'
class Employee
  include Observable # Observerとして働く</p>

<p>  attr_reader :name, :title, :salary</p>

<p>  def initialize(name, title, salary)</p>

<pre><code>@name = name
@title = title
@salary = salary
add_observer(Payroll.new)
add_observer(TaxMan.new)
</code></pre>

<p>  end</p>

<p>  # 給与をセットして、ConcreteObserverに通知する
  def salary=(new_salary)</p>

<pre><code>@salary = new_salary
changed
notify_observers(self)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>次に給与の小切手の発行を行うPayrollクラスと、税金の請求書の発行を行うTaxManクラスを作成します。これらは具体オブザーバ(ConcreteObserver)にあたります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>給与の小切手の発行を行う</h1>

<p>class Payroll
  def update(changed_employee)</p>

<pre><code>puts "彼の給料は#{changed_employee.salary}になりました！#{changed_employee.title}のために新しい小切手を切ります。"
</code></pre>

<p>  end
end</p>

<h1>税金の請求書の発行を行う</h1>

<p>class TaxMan
  def update(changed_employee)</p>

<pre><code>puts "#{changed_employee.name}に新しい税金の請求書を送ります"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>コーディングは以上です。では結果を確認します。</p>

<p>{% codeblock lang:ruby %}
john = Employee.new('John', 'Senior Vice President', 5000)
john.salary = 6000</p>

<h1>=> 彼の給料は6000になりました！Senior Vice Presidentのために新しい小切手を切ります。</h1>

<h1>=> Johnに新しい税金の請求書を送ります</h1>

<p>john.salary = 7000</p>

<h1>=> 彼の給料は7000になりました！Senior Vice Presidentのために新しい小切手を切ります。</h1>

<h1>=> Johnに新しい税金の請求書を送ります</h1>

<p>{% endcodeblock %}</p>

<p>johnのsalary(給与)を変更するとObservableによってPayrollクラスと、TaxManクラスの<code>update</code>メソッドが連動して動いていることがわかります。</p>

<p>このサンプルソースはGitHubにも置いています。</p>

<p><a href="https://github.com/morizyun/ruby_design_pattern_sample" class="button big primary">サンプルソース(GitHub)</a></p>

<h2>ストラテジーとの違い</h2>

<pre>
オブザーバ：発生しているオブジェクトに対してイベントを通知している
ストラテジー：何らかの処理を行うためにオブジェクトを取得している
</pre>


<h2>Special Thanks</h2>

<p><a href="http://murayama.hatenablog.com/entry/20090616/1245155935">Observer - Murayama Blog.</a></p>

<p><a href="http://capm-network.com/?tag=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-Observer">デザインパターン-Observer</a></p>

<p><a href="http://www.techscore.com/tech/DesignPattern/Observer.html/">17．Observer パターン</a></p>

<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4894712857&amp;linkCode=as2&amp;tag=morizyun00-22">Amazon.co.jp： Rubyによるデザインパターン: Russ Olsen, ラス・オルセン, 小林 健一, 菅野 裕, 吉野 雅人, 山岸 夢人, 小島 努: 本</a></p>

<h2>Special Thanks</h2>

<p><strong><a href="https://twitter.com/y_shindoh">@y_shindoh</a></strong>さんにコードのタイポを指摘して頂きました。
ご丁寧に間違っていた部分のdiffを作って頂けたお陰ですぐに修正出来ました。有難うございます＾＾</p>

<h2>変更来歴</h2>

<p>12/12/10 09:00 GitHubへのサンプルソースの設置。導入文の修正<br/>
12/12/11 00:00 書籍へのリンクをAmazon アフィリエイトに変更<br/>
12/12/15 23:30 ソースコードに説明を追加<br/>
13/06/20 17:40 Ruby2.0.0対応、読みづらい部分を修正<br/>
15/01/16 20:50 タイポの修正<br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0.0で学ぶ、14個のデザインパターンを作りました[GoF][Design Pattern]]]></title>
    <link href="http://morizyun.github.io/blog/ruby-design-pattern-matome-mokuzi/"/>
    <updated>2012-12-10T00:20:00+09:00</updated>
    <id>http://morizyun.github.io/blog/ruby-design-pattern-matome-mokuzi</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4894712857&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4894712857&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="200" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4894712857" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />GoFのデザインパターン 14個についての記事書いたのでまとめです。</p>

<p>GoFのデザインパターンとは、「プログラミングのベストプラクティスを体系化したもの」です。このベスト・プラクティスをしっかりと理解して設計すれば、ソフトウエア設計の効率を高めることができます。またデザインパターンが「<strong>プログラミングの思想</strong>」の共有をよりスムーズにしてくれます。先人たちの試行錯誤の結果を効果的に利用して、プログラミングをもっと楽しんでしまいましょう！</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_square.html %}</p>

<h2>デザインパターンの重要要素</h2>

<p>GoFのデザインパターンには下のプリンシパルがあります。</p>

<ul>
<li>変わるものを変わらないものから分離する</li>
<li>インターフェイスに対してプログラミングし、実装に対して行わない</li>
<li>継承より集約</li>
<li>委譲、委譲、委譲</li>
<li>必要になるまで作るな(You Ain't Gonna Need It./YAGNI)</li>
</ul>


<h2>各デザインパターンの説明</h2>

<h4>生成に関するパターン</h4>

<ul>
<li><a href="/blog/ruby-design-pattern-14-abstract-factory">アブストラクトファクトリ/Abstract Factory</a></li>
<li><a href="/blog/ruby-design-pattern-12-builder">ビルダー/Builder</a></li>
<li><a href="/blog/ruby-design-pattern-11-factory-method">ファクトリメソッド/Factory Method</a></li>
<li><a href="/blog/ruby-design-pattern-10-singleton">シングルトン/Singleton</a></li>
</ul>


<h4>構造に関するパターン</h4>

<ul>
<li><a href="/blog/ruby-design-pattern-07-adapter">アダプタ/Adapter</a></li>
<li><a href="/blog/ruby-design-pattern-04-composite">コンポジット/Composite</a></li>
<li><a href="/blog/ruby-design-pattern-09-decorator">デコレータ/Decorator</a></li>
<li><a href="/blog/ruby-design-pattern-08-proxy">プロクシ/Proxy</a></li>
</ul>


<h4>振る舞いに関するパターン</h4>

<ul>
<li><a href="/blog/ruby-design-pattern-06-command">コマンド/Command</a></li>
<li><a href="/blog/ruby-design-pattern-13-interpreter">インタープリタ/Interpreter</a></li>
<li><a href="/blog/ruby-design-pattern-05-iterator">イーテレータ/Iterator</a></li>
<li><a href="/blog/ruby-design-pattern-03-Observer">オブザーバ/Observer</a></li>
<li><a href="/blog/ruby-design-pattern-02-Strategy">ストラテジ/Strategy</a></li>
<li><a href="/blog/ruby-design-pattern-01-template-engine">テンプレートメソッド/Template Method</a></li>
</ul>


<h2>お願い事項</h2>

<p>GoFのデザインパターンは全部で22個あり、また名著「<a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4894712857&amp;linkCode=as2&amp;tag=morizyun00-22">Rubyによるデザインパターン</a>」にはRuby向けの3つのデザインパターンが書かれています。つまり、項目の網羅性という点だけでも未完成です。加えて各項目もすべて説明不十分な状態です。ただ、このデザインパターンをどこのサイトにも負けないわかりやすいコンテンツに昇華させていきたいと本気で思っています。なので間違っていたり、わかりにくい説明があればどんどんコメント欄 or 僕の Twitterアカウント(<a href="https://twitter.com/zyunnosuke">@zyunnosuke</a>)までご連絡下さい。</p>

<h2>Special Thanks</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4894712857&amp;linkCode=as2&amp;tag=morizyun00-22">Amazon.co.jp： Rubyによるデザインパターン: Russ Olsen, ラス・オルセン, 小林 健一, 菅野 裕, 吉野 雅人, 山岸 夢人, 小島 努: 本</a></p>

<h2>変更来歴</h2>

<p>12/10 23:10 FactoryをFactory MethodとAbstract Factoryに分割<br/>
12/11 00:00 書籍へのリンクをAmazon アフィリエイトに変更<br/>
06/20 17:15 Ruby 2.0.0でテストしつつ、わかりにくい部分を書きなおしました<br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[インタープリタ Ruby 2.0.0 デザインパターン速攻習得[Interpreter][Design Pattern]]]></title>
    <link href="http://morizyun.github.io/blog/ruby-design-pattern-13-interpreter/"/>
    <updated>2012-12-09T21:50:00+09:00</updated>
    <id>http://morizyun.github.io/blog/ruby-design-pattern-13-interpreter</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4894712857&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4894712857&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="200" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4894712857" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />GoFのデザインパターン(Design Pattern)の一つ、インタープリタ(Interpreter)をRubyのサンプルコードで紹介します。</p>

<p>インタープリタパターンは、1つ1つの問題はシンプルだが、組み合わさって複雑になるような場合に効果を発揮します。</p>

<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_square.html %}</p>

<h2>インタープリタとは？</h2>

<p>専用の言語を作り、その言語で得られた手順に基づいて処理を実行していくデザインパターンです。</p>

<p>インタープリタには次の構成要素があります。</p>

<pre>
抽象表現(AbstractExpression)： 共通のインタフェースを定義
終端(TerminalExpression)： 終端を表現するクラス
終端以外(NonterminalExpression)： 非終端を表現するクラス
状況、文脈(Context)： 構文の解析を手助けする
</pre>


<h2>サンプルソース</h2>

<p>サンプルとして、ファイル検索用のインタープリタを書いていきます。</p>

<p>まずは、すべてのファイル検索のベースとなる最も単純なクラスを作成します。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>命令・抽象的な表現(AbstractExpression)</h1>

<h1>Expression: 共通するコードを持つ</h1>

<p>class Expression
  def |(other)</p>

<pre><code>Or.new(self, other)
</code></pre>

<p>  end</p>

<p>  def &amp;(other)</p>

<pre><code>And.new(self, other)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>続いて、すべてのファイル名を返す<code>Allクラス</code>を作成します。
<code>evaluateメソッド</code>の概要は次の通りです。</p>

<ul>
<li>Rubyの標準ライブラリfindを使ってディレクトリ内のファイル名を収集</li>
<li>Find.findを使うことで、サブフォルダまで含めたすべてのファイルを返す</li>
</ul>


<p>{% codeblock lang:ruby %}
require "find"</p>

<h1>終端となる表現(構造木の葉) (TerminalExpression)</h1>

<h1>All: すべてのファイルを返す</h1>

<p>class All &lt; Expression
  def evaluate(dir)</p>

<pre><code>results= []
Find.find(dir) do |p|
  next unless File.file?(p)
  results &lt;&lt; p
end
results
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>続いて、与えられたパターンとマッチするすべてのファイル名を返す<code>FileNameクラス</code>を作成します。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>終端となる表現(構造木の葉) (TerminalExpression)</h1>

<h1>FileName: 与えられたパターンとマッチするすべてのファイル名を返す</h1>

<p>class FileName &lt; Expression
  def initialize(pattern)</p>

<pre><code>@pattern = pattern
</code></pre>

<p>  end</p>

<p>  def evaluate(dir)</p>

<pre><code>results= []
Find.find(dir) do |p|
  next unless File.file?(p)
  # File.basename =&gt; ファイルパスからファイル名だけを抽出
  name = File.basename(p)
  # File.fnmatch =&gt; ファイル名がパターンにマッチした場合のみtrueを返す
  results &lt;&lt; p if File.fnmatch(@pattern, name)
end
results
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>更に、指定したファイルサイズより大きいファイルを返す<code>Biggerクラス</code>を作成します。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>終端となる表現(構造木の葉) (TerminalExpression)</h1>

<h1>Bigger: 指定したファイルサイズより大きいファイルを返す</h1>

<p>class Bigger &lt; Expression
  def initialize(size)</p>

<pre><code>@size = size
</code></pre>

<p>  end</p>

<p>  def evaluate(dir)</p>

<pre><code>results = []
Find.find(dir) do |p|
  next unless File.file?(p)
  results &lt;&lt; p if( File.size(p) &gt; @size)
end
results
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>書込可能なファイルを返す<code>Writableクラス</code>は次のようになります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>終端となる表現(構造木の葉) (TerminalExpression)</h1>

<h1>Writable: 書込可能なファイルを返す</h1>

<p>class Writable &lt; Expression
  def evaluate(dir)</p>

<pre><code>results = []
Find.find(dir) do |p|
  next unless File.file?(p)
  results &lt;&lt; p if( File.writable?(p) )
end
results
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>ここで、「書込ができないファイル」を探せるように、<code>Writable</code>を否定できる<code>Notクラス</code>を作ります。<code>Notクラス</code>は、<code>Biggerクラス</code>にも適用できるので、指定したファイルサイズより小さいファイルを探せるようになります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>終端以外の表現(構造木の節) NonterminalExpression</h1>

<p>class Not &lt; Expression
  def initialize(expression)</p>

<pre><code>@expression = expression
</code></pre>

<p>  end</p>

<p>  def evaluate(dir)</p>

<pre><code>All.new.evaluate(dir) - @expression.evaluate(dir)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>最後に2つのファイル検索式を「Or」、「And」で結合するクラスを作ります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>終端以外の表現(構造木の節) NonterminalExpression</h1>

<h1>Or: 2ファイル検索式をORで結合する</h1>

<p>class Or &lt; Expression
  def initialize(expression1, expression2)</p>

<pre><code>@expression1 = expression1
@expression2 = expression2
</code></pre>

<p>  end</p>

<p>  def evaluate(dir)</p>

<pre><code>result1 = @expression1.evaluate(dir)
result2 = @expression2.evaluate(dir)
(result1 + result2).sort.uniq
</code></pre>

<p>  end
end</p>

<h1>終端以外の表現(構造木の節) NonterminalExpression</h1>

<h1>And: 2ファイル検索式をANDで結合する</h1>

<p>class And &lt; Expression
  def initialize(expression1, expression2)</p>

<pre><code>@expression1 = expression1
@expression2 = expression2
</code></pre>

<p>  end</p>

<p>  def evaluate(dir)</p>

<pre><code>result1 = @expression1.evaluate(dir)
result2 = @expression2.evaluate(dir)
(result1 &amp; result2)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>上のコードを使ってファイルを検索した結果を下に載せました。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>===========================================</h1>

<p>complex_expression1 = And.new(FileName.new('<em>.mp3'), FileName.new('big</em>'))
puts complex_expression1.evaluate('13_test_data')</p>

<h1>=> 13_test_data/big.mp3</h1>

<h1>=> 13_test_data/big2.mp3</h1>

<p>complex_expression2 = Bigger.new(1024)
puts complex_expression2.evaluate('13_test_data')</p>

<h1>=> 13_test_data/big.mp3</h1>

<h1>=> 13_test_data/big2.mp3</h1>

<h1>=> 13_test_data/subdir/other.mp3</h1>

<p>complex_expression3 = FileName.new('<em>.mp3') &amp; FileName.new('big</em>')
puts complex_expression3.evaluate('13_test_data')</p>

<h1>=> 13_test_data/big.mp3</h1>

<h1>=> 13_test_data/big2.mp3</h1>

<p>complex_expression4 = All.new
puts complex_expression4.evaluate('13_test_data')</p>

<h1>=> 13_test_data/big.mp3</h1>

<h1>=> 13_test_data/big2.mp3</h1>

<h1>=> 13_test_data/small.mp3</h1>

<h1>=> 13_test_data/small1.txt</h1>

<h1>=> 13_test_data/small2.txt</h1>

<h1>=> 13_test_data/subdir/other.mp3</h1>

<h1>=> 13_test_data/subdir/small.jpg</h1>

<p>{% endcodeblock %}</p>

<p>このように単純なインタープリタでも十分にファイル検索を実現できていることがわかります。</p>

<p>このサンプルソースはGitHubにも置いています。</p>

<p><a href="https://github.com/morizyun/ruby_design_pattern_sample" class="button big primary">サンプルソース(GitHub)</a></p>

<h2>Special Thanks</h2>

<p><a href="http://capm-network.com/?tag=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-Interpreter">デザインパターン-Interpreter</a></p>

<p><a href="http://d.hatena.ne.jp/tbpg/20120310/1331382541">RubyでInterpreterパターン／HTML5のセクション構造に対応したWebページの生成</a></p>

<p><a href="http://melborne.github.com/2011/07/25/Ruby-Interpreter/">RubyのメタプログラミングでInterpreterパターンを実装しよう！</a></p>

<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4894712857&amp;linkCode=as2&amp;tag=morizyun00-22">Amazon.co.jp： Rubyによるデザインパターン: Russ Olsen, ラス・オルセン, 小林 健一, 菅野 裕, 吉野 雅人, 山岸 夢人, 小島 努: 本</a></p>

<h2>変更来歴</h2>

<p>12/10 09:00 GitHubへのサンプルソースの設置。導入文の修正<br/>
12/10 09:55 サンプルソースの説明を追加<br/>
12/11 00:00 書籍へのリンクをAmazon アフィリエイトに変更<br/>
06/21 23:25 Ruby2.0.0対応、読みづらい部分を修正<br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ビルダー Ruby 2.0.0 デザインパターン速攻習得[Builder][Design Pattern]]]></title>
    <link href="http://morizyun.github.io/blog/ruby-design-pattern-12-builder/"/>
    <updated>2012-12-09T19:00:00+09:00</updated>
    <id>http://morizyun.github.io/blog/ruby-design-pattern-12-builder</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4894712857&linkCode=as2&tag=morizyun00-22"><img border="0" src="http://ws.assoc-amazon.jp/widgets/q?_encoding=UTF8&ASIN=4894712857&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=morizyun00-22" width="200" style="float: left; margin: 0 20px 20px 0;" ></a><img src="http://www.assoc-amazon.jp/e/ir?t=morizyun00-22&l=as2&o=9&a=4894712857" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />GoFのデザインパターン(Design Pattern)の一つ、ビルダー(Builder)をRubyのサンプルコードで紹介します。</p>

<p>ビルダーパターンは次のような場面で使われます。</p>

<pre>
オブジェクトの生成に大量のコードが必要
オブジェクトを作り出すのが難しい
オブジェクト生成時に必要なチェックを行いたい
</pre>




<!-- more -->


<br style="clear:both;"/>


<p>{% include custom/google_ads_square.html %}</p>

<h2>ビルダーとは？</h2>

<p>ビルダーは、作成過程を決定する「<strong>Director</strong>」 と作業インターフェースを持つ「<strong>Builder</strong>」を組み合わせることで、柔軟にオブジェクトを生成をすることができるデザインパターンです。</p>

<p>ビルダーには次の３つの構成要素があります。</p>

<pre>
ディレクタ(Director)：Builderで提供されているインタフェースのみを使用して処理を行う
ビルダー(Builder)：各メソッドのインタフェースを定める
具体ビルダー(ConcreteBuilder)：Builderが定めたインタフェースの実装
</pre>


<h2>サンプルソース１</h2>

<p>今回のサンプルでは、砂糖水の作成について考えます。
まず、具体ビルダー(ConcreteBuilder)として、砂糖水クラスを作ります。
この砂糖水クラスでは、砂糖と水の量を変数として持ちます。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>SugarWater： 砂糖水クラス (ConcreteBuilder：ビルダーの実装部分)</h1>

<p>class SugarWater
  attr_accessor :water, :sugar
  def initialize(water, sugar)</p>

<pre><code>@water = water
@sugar = sugar
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>次にBuilderとして、<code>SugarWaterBuilderクラス</code>を作ります。
このクラスは砂糖水を作るためのインターフェイスと考えることができます。
このクラスに以下の３つのメソッドを追加します。</p>

<pre>
add_sugar: 砂糖を加える
add_water: 水を加える
result: 砂糖水の状態を返す
</pre>


<p>{% codeblock lang:ruby %}</p>

<h1>SugarWaterBuilder: 砂糖水を生成するためのインターフェイス (Builder)</h1>

<p>class SugarWaterBuilder
  def initialize</p>

<pre><code>@sugar_water = SugarWater.new(0,0)
</code></pre>

<p>  end</p>

<p>  # 砂糖を加える
  def add_sugar(sugar_amount)</p>

<pre><code>@sugar_water.sugar += sugar_amount
</code></pre>

<p>  end</p>

<p>  # 水を加える
  def add_water(water_amount)</p>

<pre><code>@sugar_water.water += water_amount
</code></pre>

<p>  end</p>

<p>  # 砂糖水の状態を返す
  def result</p>

<pre><code>@sugar_water
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>最後に砂糖水を作るための作成過程(cook)のメソッドを持つ、<code>Directorクラス</code>を作ります。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>Director： 砂糖水の作成過程を取り決める</h1>

<p>class Director
  def initialize(builder)</p>

<pre><code>@builder = builder
</code></pre>

<p>  end
  # 砂糖水の作成過程を定義する
  def cook</p>

<pre><code>@builder.add_water(150)
@builder.add_sugar(90)
@builder.add_water(300)
@builder.add_sugar(35)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>このプログラムを呼び出します。これで砂糖水を生成することができます。</p>

<p>{% codeblock lang:ruby %}
builder = SugarWaterBuilder.new
director = Director.new(builder)
director.cook
{% endcodeblock %}</p>

<p>この実行結果の砂糖水は次のようになりました。</p>

<p>{% codeblock lang:ruby %}
p builder.result</p>

<h1>=> &lt;SugarWater:0x007fc773085bc8 @water=450, @sugar=125></h1>

<p>{% endcodeblock %}</p>

<p>このようにBuilder側に作業を担当してもらい、Director側に作業過程を担当してもらうことで、オブジェクトの生成が柔軟にできるイメージを持てたと思います。</p>

<h2>サンプルソース２</h2>

<p>サンプル１では砂糖水を作成するだけでしたが、サンプル２では塩水も作成できるようにします。まず、塩水の<code>SaltWaterクラス</code>を追加します。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>SaltWater 塩水クラス (ConcreteBuilder：ビルダーの実装部分)</h1>

<p>class SaltWater
  attr_accessor :water, :salt
  def initialize(water, salt)</p>

<pre><code>@water = water
@salt = salt
</code></pre>

<p>  end</p>

<p>  # 素材(塩)を加える
  def add_material(salt_amount)</p>

<pre><code>@salt += salt_amount
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>続いて砂糖水クラスを変更します。
素材を追加するクラスを塩水クラスと共通するために、メソッド名を<code>add_material</code>にします。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>SugarWater： 砂糖水クラス (ConcreteBuilder：ビルダーの実装部分)</h1>

<p>class SugarWater
  attr_accessor :water, :sugar
  def initialize(water, sugar)</p>

<pre><code>@water = water
@sugar = sugar
</code></pre>

<p>  end</p>

<p>  # 素材(砂糖)を加える
  def add_material(sugar_amount)</p>

<pre><code>@sugar += sugar_amount
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>続いてBuilderの変更を行います。変更点は次の２点です。</p>

<ul>
<li>Builderのクラス名を<code>WaterWithMaterialBuilderクラス</code>に変更</li>
<li>素材を入れるメソッドの名称を<code>add_materialメソッド</code>に変更</li>
</ul>


<p>{% codeblock lang:ruby %}</p>

<h1>SugarWaterBuilder： 加工した水を生成するためのインターフェイス(Builder)</h1>

<p>class WaterWithMaterialBuilder
  def initialize(class_name)</p>

<pre><code>@water_with_material = class_name.new(0,0)
</code></pre>

<p>  end</p>

<p>  # 素材を入れる
  def add_material(material_amount)</p>

<pre><code>@water_with_material.add_material(material_amount)
</code></pre>

<p>  end</p>

<p>  # 水を加える
  def add_water(water_amount)</p>

<pre><code>@water_with_material.water += water_amount
</code></pre>

<p>  end</p>

<p>  # 加工水の状態を返す
  def result</p>

<pre><code>@water_with_material
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>最後にDirectorクラスです。こちらもadd_sugarメソッドを<code>add_materialメソッド</code>に変更しています。</p>

<p>{% codeblock lang:ruby %}</p>

<h1>Director： 加工水の作成過程を取り決める</h1>

<p>class Director
  def initialize(builder)</p>

<pre><code>@builder = builder
</code></pre>

<p>  end
  def cook</p>

<pre><code>@builder.add_water(150)
@builder.add_material(90)
@builder.add_water(300)
@builder.add_material(35)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>変更したソースでの結果を確認します。
まず砂糖水の生成です。サンプルソース1と同様の結果になりました。</p>

<p>{% codeblock lang:ruby %}
builder = WaterWithMaterialBuilder.new(SugarWater)
director = Director.new(builder)
director.cook</p>

<p>p builder.result</p>

<h1>=> #&lt;SugarWater:0x007fc773085bc8 @water=450, @sugar=125></h1>

<p>{% endcodeblock %}</p>

<p>続いて、塩水の生成です。塩水が生成されていることがわかります。</p>

<p>{% codeblock lang:ruby %}
builder = WaterWithMaterialBuilder.new(SaltWater)
director = Director.new(builder)
director.cook</p>

<p>p builder.result</p>

<h1>#&lt;SaltWater:0x007f92cc103ba8 @water=450, @salt=125></h1>

<p>{% endcodeblock %}</p>

<p>このサンプルソースはGitHubにも置いています。</p>

<p><a href="https://github.com/morizyun/ruby_design_pattern_sample" class="button big primary">サンプルソース(GitHub)</a></p>

<h2>Special Thanks</h2>

<p><a href="http://d.hatena.ne.jp/ryo_43z/20080813/1218646688">デザインパターンbuilder</a></p>

<p><a href="http://capm-network.com/?tag=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-Builder">デザインパターン-Builder</a></p>

<p><a href="http://www.amazon.co.jp/gp/product/4894712857/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4894712857&amp;linkCode=as2&amp;tag=morizyun00-22">Amazon.co.jp： Rubyによるデザインパターン: Russ Olsen, ラス・オルセン, 小林 健一, 菅野 裕, 吉野 雅人, 山岸 夢人, 小島 努: 本</a></p>

<h2>変更来歴</h2>

<p>12/10 09:00 GitHubへのサンプルソースの設置。導入文の修正<br/>
12/10 15:25 「どんな時に使うか？」、「サンプルソース２の説明」を追加<br/>
12/11 00:00 書籍へのリンクをAmazon アフィリエイトに変更<br/>
06/21 23:05 Ruby2.0.0対応、読みづらい部分を修正<br/></p>
]]></content>
  </entry>
  
</feed>
